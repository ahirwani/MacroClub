Exp_YTM_Cont <- mean(log(Bond_payout_p/Bond_price))
hist(Bond_payout_p, main =paste("Bond payout under real prob, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count")
print(c("Default Probability","Expected YTM","Expected Continuos YTM"),c(Default_prob,Exp_YTM,Exp_YTM_Cont))
}
par(mfrow=c(2,2))
merton_model(0.1,0.3)
par(mfrow=c(2,2))
merton_model(0.1,0.3)
merton_model <- function(mu,sigma)
{
#Params for pricing
u <- exp(sigma*sqrt(T/Nperiods))
d <- 1/u
#Risk-neutral measure
q <- (exp(rf*dt)-d)/(u-d)
A_path <- matrix(A0, nrow = Nsims, ncol = Nperiods+1)
u_shock <- matrix(runif(Nsims*Nperiods), nrow = Nsims, ncol = Nperiods)
isUp <- u_shock <= q
R <- u*(isUp) + d*(!isUp)
A_path[,-1] <- A0*t(apply(R, 1, cumprod))
A_terminal <- A_path[,Nperiods+1]
Bond_payout <- (pmin(A_terminal,F))
Bond_price <- exp(-rf*T) * mean(Bond_payout)
Promised_ytm <- F/Bond_price -1        #Non-continuos
Promised_ytm_cont <- log(F/Bond_price)
hist(Bond_payout, main =paste("Bond payout under risk neutral, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count")
print(c("Bond price","Promised YTM","Promised Continuos YTM"))
print(c(Bond_price,Promised_ytm,Promised_ytm_cont))
#Real measure
p=0.5+0.5*(mu/sigma)*sqrt(T/Nperiods)
A_path_p <- matrix(A0, nrow = Nsims, ncol = Nperiods+1)
u_shock_p <- matrix(runif(Nsims*Nperiods), nrow = Nsims, ncol = Nperiods)
isUp_p <- u_shock_p <= p
R_p <- u*(isUp_p) + d*(!isUp_p)
A_path_p[,-1] <- A0*t(apply(R_p, 1, cumprod))
A_terminal_p <- A_path_p[,Nperiods+1]
Bond_payout_p <- (pmin(A_terminal_p,F))
Default_prob <- mean(Bond_payout_p<F)
Exp_YTM <- mean(Bond_payout_p/Bond_price-1)
Exp_YTM_Cont <- mean(log(Bond_payout_p/Bond_price))
hist(Bond_payout_p, main =paste("Bond payout under real prob, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count")
print(c("Default Probability","Expected YTM","Expected Continuos YTM"))
print(c(Default_prob,Exp_YTM,Exp_YTM_Cont))
}
par(mfrow=c(2,2))
merton_model(0.1,0.3)
merton_model <- function(mu,sigma)
{
#Params for pricing
u <- exp(sigma*sqrt(T/Nperiods))
d <- 1/u
#Risk-neutral measure
q <- (exp(rf*dt)-d)/(u-d)
A_path <- matrix(A0, nrow = Nsims, ncol = Nperiods+1)
u_shock <- matrix(runif(Nsims*Nperiods), nrow = Nsims, ncol = Nperiods)
isUp <- u_shock <= q
R <- u*(isUp) + d*(!isUp)
A_path[,-1] <- A0*t(apply(R, 1, cumprod))
A_terminal <- A_path[,Nperiods+1]
Bond_payout <- (pmin(A_terminal,F))
Bond_price <- exp(-rf*T) * mean(Bond_payout)
Promised_ytm <- F/Bond_price -1        #Non-continuos
Promised_ytm_cont <- log(F/Bond_price)
hist(Bond_payout, main =paste("Bond payout under risk neutral, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count",cex.main=1/3)
print(c("Bond price","Promised YTM","Promised Continuos YTM"))
print(c(Bond_price,Promised_ytm,Promised_ytm_cont))
#Real measure
p=0.5+0.5*(mu/sigma)*sqrt(T/Nperiods)
A_path_p <- matrix(A0, nrow = Nsims, ncol = Nperiods+1)
u_shock_p <- matrix(runif(Nsims*Nperiods), nrow = Nsims, ncol = Nperiods)
isUp_p <- u_shock_p <= p
R_p <- u*(isUp_p) + d*(!isUp_p)
A_path_p[,-1] <- A0*t(apply(R_p, 1, cumprod))
A_terminal_p <- A_path_p[,Nperiods+1]
Bond_payout_p <- (pmin(A_terminal_p,F))
Default_prob <- mean(Bond_payout_p<F)
Exp_YTM <- mean(Bond_payout_p/Bond_price-1)
Exp_YTM_Cont <- mean(log(Bond_payout_p/Bond_price))
hist(Bond_payout_p, main =paste("Bond payout under real prob, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count",cex.main=2/3)
print(c("Default Probability","Expected YTM","Expected Continuos YTM"))
print(c(Default_prob,Exp_YTM,Exp_YTM_Cont))
}
merton_model(0.1,0.3)
par(mfrow=c(2,2),cex.main=0.75, ps=10)
merton_model(0.1,0.3)
par(mfrow=c(2,2),ps=10)
merton_model <- function(mu,sigma)
{
#Params for pricing
u <- exp(sigma*sqrt(T/Nperiods))
d <- 1/u
#Risk-neutral measure
q <- (exp(rf*dt)-d)/(u-d)
A_path <- matrix(A0, nrow = Nsims, ncol = Nperiods+1)
u_shock <- matrix(runif(Nsims*Nperiods), nrow = Nsims, ncol = Nperiods)
isUp <- u_shock <= q
R <- u*(isUp) + d*(!isUp)
A_path[,-1] <- A0*t(apply(R, 1, cumprod))
A_terminal <- A_path[,Nperiods+1]
Bond_payout <- (pmin(A_terminal,F))
Bond_price <- exp(-rf*T) * mean(Bond_payout)
Promised_ytm <- F/Bond_price -1        #Non-continuos
Promised_ytm_cont <- log(F/Bond_price)
hist(Bond_payout, main =paste("Bond payout under risk neutral, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count",cex.main=0.75)
print(c("Bond price","Promised YTM","Promised Continuos YTM"))
print(c(Bond_price,Promised_ytm,Promised_ytm_cont))
#Real measure
p=0.5+0.5*(mu/sigma)*sqrt(T/Nperiods)
A_path_p <- matrix(A0, nrow = Nsims, ncol = Nperiods+1)
u_shock_p <- matrix(runif(Nsims*Nperiods), nrow = Nsims, ncol = Nperiods)
isUp_p <- u_shock_p <= p
R_p <- u*(isUp_p) + d*(!isUp_p)
A_path_p[,-1] <- A0*t(apply(R_p, 1, cumprod))
A_terminal_p <- A_path_p[,Nperiods+1]
Bond_payout_p <- (pmin(A_terminal_p,F))
Default_prob <- mean(Bond_payout_p<F)
Exp_YTM <- mean(Bond_payout_p/Bond_price-1)
Exp_YTM_Cont <- mean(log(Bond_payout_p/Bond_price))
hist(Bond_payout_p, main =paste("Bond payout under real prob, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count",cex.main=0.75)
print(c("Default Probability","Expected YTM","Expected Continuos YTM"))
print(c(Default_prob,Exp_YTM,Exp_YTM_Cont))
}
merton_model(0.1,0.3)
par(mfrow=c(2,2))
merton_model(0.1,0.3)
merton_model <- function(mu,sigma)
{
#Params for pricing
u <- exp(sigma*sqrt(T/Nperiods))
d <- 1/u
#Risk-neutral measure
q <- (exp(rf*dt)-d)/(u-d)
A_path <- matrix(A0, nrow = Nsims, ncol = Nperiods+1)
u_shock <- matrix(runif(Nsims*Nperiods), nrow = Nsims, ncol = Nperiods)
isUp <- u_shock <= q
R <- u*(isUp) + d*(!isUp)
A_path[,-1] <- A0*t(apply(R, 1, cumprod))
A_terminal <- A_path[,Nperiods+1]
Bond_payout <- (pmin(A_terminal,F))
Bond_price <- exp(-rf*T) * mean(Bond_payout)
Promised_ytm <- F/Bond_price -1        #Non-continuos
Promised_ytm_cont <- log(F/Bond_price)
hist(Bond_payout, main =paste("Bond payout under risk neutral, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count",cex.main=1)
print(c("Bond price","Promised YTM","Promised Continuos YTM"))
print(c(Bond_price,Promised_ytm,Promised_ytm_cont))
#Real measure
p=0.5+0.5*(mu/sigma)*sqrt(T/Nperiods)
A_path_p <- matrix(A0, nrow = Nsims, ncol = Nperiods+1)
u_shock_p <- matrix(runif(Nsims*Nperiods), nrow = Nsims, ncol = Nperiods)
isUp_p <- u_shock_p <= p
R_p <- u*(isUp_p) + d*(!isUp_p)
A_path_p[,-1] <- A0*t(apply(R_p, 1, cumprod))
A_terminal_p <- A_path_p[,Nperiods+1]
Bond_payout_p <- (pmin(A_terminal_p,F))
Default_prob <- mean(Bond_payout_p<F)
Exp_YTM <- mean(Bond_payout_p/Bond_price-1)
Exp_YTM_Cont <- mean(log(Bond_payout_p/Bond_price))
hist(Bond_payout_p, main =paste("Bond payout under real prob, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count",cex.main=1)
print(c("Default Probability","Expected YTM","Expected Continuos YTM"))
print(c(Default_prob,Exp_YTM,Exp_YTM_Cont))
}
par(mfrow=c(2,2))
merton_model(0.1,0.3)
rm(list=ls())
library(moments)
library(fOptions)
set.seed(12345)
rf <- 0.05
mu <- 0.1
theta <- 4
eta_x <- -0.2
gamma_x <- 2
dt <- 1/52
S0 <- 1
Nsims <- 100000
sqrt_dt <- sqrt(dt)
K <- seq(0.9,1.1,0.01)
call_stochvol <- function(T, rho, x_bar)              #T in weeks
{
#Initialize
x0 <- x_bar
rho_comp <- sqrt(1-rho^2)
S_path <- matrix(S0, nrow=Nsims, ncol=T+1)
v_path <- matrix(exp(x0), nrow=Nsims, ncol=T+1)
x_path <- matrix(x0, nrow=Nsims, ncol=T+1)
#shocks
eps_S <- matrix(rnorm(Nsims*T,0,1),nrow=Nsims,ncol=T)          #note how shock for S_path[,2] is stored in eps_S[,1]
eps_x <- matrix(rnorm(Nsims*T,0,1),nrow=Nsims,ncol=T)
eta_S <- ((mu-rf)/v_path)
#Compute path
for(i in 2:(T+1))
{
S_path[,i] <- S_path[,i-1]* exp((rf-0.5*(v_path[,i-1]^2))*dt + v_path[,i-1]*sqrt_dt*eps_S[,i-1])
x_path[,i] <- x_path[,i-1] - theta*dt*(x_path[,i-1]-x_bar) - (rho*eta_S[,i-1] + rho_comp*eta_x)*gamma_x*dt +
gamma_x*sqrt_dt*(rho*eps_S[,i-1] + rho_comp*eps_x[,i-1])
v_path[,i] <- exp(x_path[,i])
eta_S[,i]  <- (mu-rf)/(v_path[,i])
}
S_term <- S_path[,T+1]
which(is.nan(S_term))
x_path[6397,]
eps_x[6397,]
call_price <- rep(0,21)                 #for different strikes
call_impvol <- rep(0,21)
for(i in 1:21)
{
mean(pmax(S_term[1:9999]-K[i],0))
call_price[i] <- exp(-rf*T*dt)*mean(pmax(S_term-K[i],0))
call_impvol[i] <- GBSVolatility(call_price[i], TypeFlag = "c", S=S0, X=K[i], r=rf, b=rf, Time = T*dt)
}
return(call_impvol)
}
plotter <- function(Call_Impvols, rho, x_bar)         #Take a list of impvols for different time to maturity and plot
{
ymin <- min(Call_Impvols$T1,Call_Impvols$T2,Call_Impvols$T3)
ymax <- max(Call_Impvols$T1,Call_Impvols$T2,Call_Impvols$T3)
plot(K, Call_Impvols$T1, col="black", xlab="Strike", ylab="Implied Vol", type='b', ylim =c(ymin-0.02,ymax+0.03),
main= paste("Implied Vol vs Strike for rho =",rho," and x_bar =",x_bar))
lines(K, Call_Impvols$T2, col="blue", type='b')
lines(K, Call_Impvols$T3, col="green", type='b')
legend("topright", legend=c("12 weeks", "24 weeks","36 weeks"),col=c("black","blue","green"),lty=1)
}
par(ps = 10)
P1_12weeks <- call_stochvol(12, 0, log(0.1))
P1_24weeks <- call_stochvol(24, 0, log(0.1))
P1_36weeks <- call_stochvol(36, 0, log(0.1))
plotter(list(T1=P1_12weeks, T2= P1_24weeks , T3= P1_36weeks),0,"log(0.1)")
par(ps = 10)
P2_12weeks <- call_stochvol(12, -0.8, log(0.1))
P2_24weeks <- call_stochvol(24, -0.8, log(0.1))
P2_36weeks <- call_stochvol(36, -0.8, log(0.1))
plotter(list(T1=P2_12weeks, T2= P2_24weeks , T3= P2_36weeks),-0.8,"log(0.1)")
par(ps = 10)
P3a_12weeks <- call_stochvol(12, -0.5, log(0.05))
P3a_24weeks <- call_stochvol(24, -0.5, log(0.05))
P3a_36weeks <- call_stochvol(36, -0.5, log(0.05))
plotter(list(T1=P3a_12weeks, T2= P3a_24weeks , T3= P3a_36weeks),-0.5,"log(0.05)")
P3b_12weeks <- call_stochvol(12, -0.5, log(0.1))
P3b_24weeks <- call_stochvol(24, -0.5, log(0.1))
P3b_36weeks <- call_stochvol(36, -0.5, log(0.1))
plotter(list(T1=P3b_12weeks, T2= P3b_24weeks , T3= P3b_36weeks),-0.5,"log(0.1)")
par(ps = 10)
P3c_12weeks <- call_stochvol(12, -0.5, log(0.15))
P3c_24weeks <- call_stochvol(24, -0.5, log(0.15))
P3c_36weeks <- call_stochvol(36, -0.5, log(0.15))
plotter(list(T1=P3c_12weeks, T2= P3c_24weeks , T3= P3c_36weeks),-0.5,"log(0.15)")
rm(list=ls())
library(moments)
library(fOptions)
set.seed(12345)
rf <- 0.03
dt <- 1/252
A0 <- 1
Nsims <- 100000
F <- 0.8
T <- 1
Nperiods <- T/dt
merton_model <- function(mu,sigma)
{
#Params for pricing
u <- exp(sigma*sqrt(T/Nperiods))
d <- 1/u
#Risk-neutral measure
q <- (exp(rf*dt)-d)/(u-d)
A_path <- matrix(A0, nrow = Nsims, ncol = Nperiods+1)
u_shock <- matrix(runif(Nsims*Nperiods), nrow = Nsims, ncol = Nperiods)
isUp <- u_shock <= q
R <- u*(isUp) + d*(!isUp)
A_path[,-1] <- A0*t(apply(R, 1, cumprod))
A_terminal <- A_path[,Nperiods+1]
Bond_payout <- (pmin(A_terminal,F))
Bond_price <- exp(-rf*T) * mean(Bond_payout)
Promised_ytm <- F/Bond_price -1        #Non-continuos
Promised_ytm_cont <- log(F/Bond_price)
hist(Bond_payout, main =paste("Bond payout under risk neutral, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count",cex.main=1)
print(c("Bond price","Promised YTM","Promised Continuos YTM"))
print(c(Bond_price,Promised_ytm,Promised_ytm_cont))
#Real measure
p=0.5+0.5*(mu/sigma)*sqrt(T/Nperiods)
A_path_p <- matrix(A0, nrow = Nsims, ncol = Nperiods+1)
u_shock_p <- matrix(runif(Nsims*Nperiods), nrow = Nsims, ncol = Nperiods)
isUp_p <- u_shock_p <= p
R_p <- u*(isUp_p) + d*(!isUp_p)
A_path_p[,-1] <- A0*t(apply(R_p, 1, cumprod))
A_terminal_p <- A_path_p[,Nperiods+1]
Bond_payout_p <- (pmin(A_terminal_p,F))
Default_prob <- mean(Bond_payout_p<F)
Exp_YTM <- mean(Bond_payout_p/Bond_price-1)
Exp_YTM_Cont <- mean(log(Bond_payout_p/Bond_price))
hist(Bond_payout_p, main =paste("Bond payout under real prob, mu=",mu," sigma=",sigma),
breaks=30,col='blue',xlab="Bond_Payout",ylab="Count",cex.main=1)
print(c("Default Probability","Expected YTM","Expected Continuos YTM"))
print(c(Default_prob,Exp_YTM,Exp_YTM_Cont))
}
par(mfrow=c(2,2))
merton_model(0.1,0.3)
merton_model(0.05,0.3)
merton_model(0.15,0.3)
merton_model(0.1,0.2)
merton_model(0.15,0.3)
par(mfrow=c(2,2))
merton_model(0.15,0.3)
merton_model(0.1,0.2)
merton_model(0.1,0.4)
rm(list=ls())
assign("last.warning", NULL, envir = baseenv())
library(moments)
library(ggplot2)
library(gridExtra)
set.seed(12345)
sigma <- 0.2
mu <- 0.1
rf <- 0.04
gamma <- 2
S0 <- 1
W0 <- 2
Nyears <- 2
dt <- 1/52
Nperiods <- Nyears/dt
Nsims <- 100000
u <- exp(sigma*sqrt(dt))
d <- 1/u
p <- (exp(mu*dt)-d)/(u-d)
pi_u <- 1/(p*(1+rf*dt)) * (1+rf*dt - d) / (u - d)
pi_d <- 1/((1-p)*(1+rf*dt)) * (u - (1+rf*dt)) / (u - d)
times_up <- seq(Nperiods,0,-1)
pi_T <- pi_u^times_up * pi_d^(Nperiods-times_up)
prob_T <- choose(Nperiods,times_up) * p^times_up * (1-p)^(Nperiods-times_up)
S_T <- S0 * u^times_up * d^(Nperiods-times_up)
find_lambda <- function(lambda){
W_T <- pmax(1/(lambda*pi_T),0.9)
cost <- sum(prob_T * pi_T * W_T)
return(cost - W0)
}
solve_lambda <- uniroot(find_lambda, c(0.01, 10))
lambda <- solve_lambda$root
W <- matrix(NA, nrow=Nperiods+1, ncol=Nperiods+1)
W[, Nperiods+1] <- pmax(1/(lambda*pi_T),0.9)
thetaS <- matrix(NA, nrow=Nperiods, ncol=Nperiods)
thetaB <- matrix(NA, nrow=Nperiods, ncol=Nperiods)
for (n in seq(Nperiods,1,-1)){
### Wealth process
# Wealth next period, up and down
W_up <- W[1:n, n+1]
W_down <- W[2:(n+1), n+1]
# Wealth this period, store in matrix
Wt <- p*pi_u*W_up + (1-p)*pi_d*W_down
W[1:n, n] <- Wt
### Portfolio holdings
# Current stock price
jt <- seq(n-1,0,-1)
St <- S0 * u^jt * d^(n-1-jt)
# Strategy
thetaSt <- (W_up - W_down) / ((u-d)*St)
thetaS[1:n, n] <- thetaSt
thetaBt <- Wt - thetaSt*St
thetaB[1:n, n] <- thetaBt
}
sigma <- 0.2
mu <- 0.1
rf <- 0.04
gamma <- 2
S0 <- 1
W0 <- 1
Nyears <- 2
dt <- 1/52
Nperiods <- Nyears/dt
Nsims <- 100000
u <- exp(sigma*sqrt(dt))
d <- 1/u
p <- (exp(mu*dt)-d)/(u-d)
pi_u <- 1/(p*(1+rf*dt)) * (1+rf*dt - d) / (u - d)
pi_d <- 1/((1-p)*(1+rf*dt)) * (u - (1+rf*dt)) / (u - d)
times_up <- seq(Nperiods,0,-1)
pi_T <- pi_u^times_up * pi_d^(Nperiods-times_up)
prob_T <- choose(Nperiods,times_up) * p^times_up * (1-p)^(Nperiods-times_up)
S_T <- S0 * u^times_up * d^(Nperiods-times_up)
find_lambda <- function(lambda){
W_T <- pmax(1/(lambda*pi_T),0.9)
cost <- sum(prob_T * pi_T * W_T)
return(cost - W0)
}
solve_lambda <- uniroot(find_lambda, c(0.01, 10))
lambda <- solve_lambda$root
rm(list=ls())
assign("last.warning", NULL, envir = baseenv())
library(moments)
library(ggplot2)
library(gridExtra)
set.seed(12345)
sigma <- 0.2
mu <- 0.1
rf <- 0.04
gamma <- 2
S0 <- 1
W0 <- 1
Nyears <- 2
dt <- 1/52
Nperiods <- Nyears/dt
Nsims <- 100000
u <- exp(sigma*sqrt(dt))
d <- 1/u
p <- (exp(mu*dt)-d)/(u-d)
pi_u <- 1/(p*(1+rf*dt)) * (1+rf*dt - d) / (u - d)
pi_d <- 1/((1-p)*(1+rf*dt)) * (u - (1+rf*dt)) / (u - d)
times_up <- seq(Nperiods,0,-1)
pi_T <- pi_u^times_up * pi_d^(Nperiods-times_up)
prob_T <- choose(Nperiods,times_up) * p^times_up * (1-p)^(Nperiods-times_up)
S_T <- S0 * u^times_up * d^(Nperiods-times_up)
find_lambda <- function(lambda){
W_T <- pmax(1/(lambda*pi_T),0.9)
cost <- sum(prob_T * pi_T * W_T)
return(cost - W0)
}
solve_lambda <- uniroot(find_lambda, c(0.01, 10))
lambda <- solve_lambda$root
W <- matrix(NA, nrow=Nperiods+1, ncol=Nperiods+1)
W[, Nperiods+1] <- pmax(1/(lambda*pi_T),0.9)
thetaS <- matrix(NA, nrow=Nperiods, ncol=Nperiods)
thetaB <- matrix(NA, nrow=Nperiods, ncol=Nperiods)
for (n in seq(Nperiods,1,-1)){
### Wealth process
# Wealth next period, up and down
W_up <- W[1:n, n+1]
W_down <- W[2:(n+1), n+1]
# Wealth this period, store in matrix
Wt <- p*pi_u*W_up + (1-p)*pi_d*W_down
W[1:n, n] <- Wt
### Portfolio holdings
# Current stock price
jt <- seq(n-1,0,-1)
St <- S0 * u^jt * d^(n-1-jt)
# Strategy
thetaSt <- (W_up - W_down) / ((u-d)*St)
thetaS[1:n, n] <- thetaSt
thetaBt <- Wt - thetaSt*St
thetaB[1:n, n] <- thetaBt
}
print(c(lambda,thetaB[1],thetaS[1]))
View(thetaB)
print(c(lambda,thetaB[1,1],thetaS[1,1]))
rm(list = ls())
setwd("/Users//adhya/Documents/R_Macro/MacroClub/")
library(openxlsx)
library(xlsx)
library(lubridate)
library(zoo)
library(xts)
library(moments)
library(PerformanceAnalytics)
data.macro <- read.xlsx("MacroIndices.xlsx")
data.macro[,1] <- convertToDate(data.macro[,1],origin="1899-12-30")
data_ret_frame <-data.macro[-1,]
data_ret_frame[,2:ncol(data.macro)] <- log(data.macro[-1,-1]/data.macro[-nrow(data.macro),-1])
data_ret <- xts(data_ret_frame[,-1],order.by = as.Date(data_ret_frame[,1], "%m/%d/%Y"))
monthly_day<- seq(21,nrow(data_ret),21)
cum_return_21day <- rollapply(data_ret,width=21,sum)
monthly_returns <-cum_return_21day[monthly_day][-1,1:9]            #Dont use t bills/ notes since they are safe
data_month <-data.frame(coredata(monthly_returns))                 #convert to data frame
data_month_all <- data.frame(coredata(cum_return_21day[monthly_day][-1,]))           #in case you need all
rf <- 0.001              #Monthly risk free from T-Bills
data_returns <- monthly_returns
mean_ret <- colMeans(data_returns)
cov_ret <- cov(data_returns)
cov_inv <- solve(cov_ret)
turbulence <- apply(data_returns,1, function(x) sqrt(0.5* (t(x-mean_ret)%*% cov_inv %*%(x-mean_ret))))
hmm <- depmix(turbulence ~ 1, family = gaussian(), nstates = 3, data=data.frame(turbulence=turbulence))
library('depmixS4')
library('quantmod')
hmm <- depmix(turbulence ~ 1, family = gaussian(), nstates = 3, data=data.frame(turbulence=turbulence))
hmmfit <- fit(hmm, verbose = FALSE)
post_probs <- posterior(hmmfit)
statedef <- state_descript(hmmfit)
transition <- trmat(hmmfit)
trmat <- function ( d ) {
M <- attributes ( d ) $ nstates
Mat <- matrix ( 0, M, M )
for ( i in 1 : M ) {
for ( j in 1 : M ) {
Mat [ i, j ] <- ( attributes ( d ) $ transition [[ i ]] )@ parameters $ coefficients [ j ]
}
}
return(Mat)
}
state_descript <- function ( d ) {
M <- attributes ( d ) $ nstates
Mat <- matrix ( 0, M)
for ( i in 1 : M ) {
Mat [ i ] <- unname((attributes(d) $response[[i]])[[1]] @parameters $coefficients)
}
return(Mat)
}
statedef <- state_descript(hmmfit)
transition <- trmat(hmmfit)
plot(index(monthly_returns),turbulence,type='l', col="black", main='Historical Turbulence', cex.main=0.9, xlab='', ylab='Turbulence', lwd=0.8)
plot(index(monthly_returns),post_probs$state, type='l', main='Regime Posterior Probabilities',
ylab='State',xlab='Date', cex.main=0.9)
hmm <- depmix(turbulence ~ 1, family = gaussian(), nstates = 2, data=data.frame(turbulence=turbulence))
hmmfit <- fit(hmm, verbose = FALSE)
post_probs <- posterior(hmmfit)
plot(index(monthly_returns),post_probs$state, type='l', main='Regime Posterior Probabilities',
ylab='State',xlab='Date', cex.main=0.9)
